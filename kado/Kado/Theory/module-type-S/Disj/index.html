<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Disj (kado.Kado.Theory.S.Disj)</title><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.3.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">kado</a> &#x00BB; <a href="../../../index.html">Kado</a> &#x00BB; <a href="../../index.html">Theory</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Disj</nav><header class="odoc-preamble"><h1>Module <code><span>S.Disj</span></code></h1><p>Disjunctive theories over the interval.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-disj_thy">disj_thy</a></span></code></div><div class="spec-doc"><p>The type of a disjunctive theory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The empty theory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-consistency"><a href="#val-consistency" class="anchor"></a><code><span><span class="keyword">val</span> consistency : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `Consistent <span>| `Inconsistent</span> ]</span></span></code></div><div class="spec-doc"><p><code>consistency thy</code> returns the consistency of the theory <code>thy</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-cof">cof</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>assume thy cofs</code> assumes <code>cofs</code> and returns the new theory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-test_sequent"><a href="#val-test_sequent" class="anchor"></a><code><span><span class="keyword">val</span> test_sequent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-cof">cof</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-cof">cof</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>test_sequent thy context cof</code> tests the validity of a sequent against the supplied theory. Equivalent to assuming the cofibrations <code>context</code> and then testing truthness of <code>cof</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-envelope_alg"><a href="#val-envelope_alg" class="anchor"></a><code><span><span class="keyword">val</span> envelope_alg : <span><a href="../Alg/index.html#type-t">Alg.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>envelope_alg thy</code> constructs the enveloping disjunctive theory of the algebraic theory <code>thy</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decompose"><a href="#val-decompose" class="anchor"></a><code><span><span class="keyword">val</span> decompose : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Alg/index.html#type-t">Alg.t</a> list</span></span></code></div><div class="spec-doc"><p><code>decompose thy</code> returns irreducible joins as algebraic theories.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-simplify_cof"><a href="#val-simplify_cof" class="anchor"></a><code><span><span class="keyword">val</span> simplify_cof : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-cof">cof</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-cof">cof</a></span></code></div><div class="spec-doc"><p><code>simplify_cof thy cof</code> returns a potentially simplified cofibration that is equivalent to <code>cof</code>. This is useful for displaying sensible cofibrations to users. While it will remove useless cofibrations such as <code>r=r</code> and <code>0=1</code>, it does not perform non-local simplification such as reducing <code>x=1 /\ x=1</code> to <code>x=1</code>. Also, the simplification is an expensive process and should be used wisely.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forall_cof"><a href="#val-forall_cof" class="anchor"></a><code><span><span class="keyword">val</span> forall_cof : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Param/index.html#type-dim">Param.dim</a> * <a href="../index.html#type-cof">cof</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-cof">cof</a></span></code></div><div class="spec-doc"><p><code>forall_cof thy (r, cof)</code> computes <code>forall r. cof</code> with respect to the equations in the theory <code>thy</code>, using the syntactic quantifier elimination and potentially other simplification procedures used in <a href="../../../Builder/Endo/module-type-S/index.html#val-eq"><code>Builder.Endo.S.eq</code></a>, <a href="../../../Builder/Endo/module-type-S/index.html#val-join"><code>Builder.Endo.S.join</code></a>, and <a href="../../../Builder/Endo/module-type-S/index.html#val-meet"><code>Builder.Endo.S.meet</code></a>. This is slower than <a href="../../../Builder/Endo/module-type-S/index.html#val-forall"><code>Builder.Endo.S.forall</code></a> which does not take equations into consideration.</p><p>Note: this is experimental and might be removed if it turns out that we do not need it. Also, <code>r</code> cannot be <code>dim0</code> or <code>dim1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-meet2"><a href="#val-meet2" class="anchor"></a><code><span><span class="keyword">val</span> meet2 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>meet2 thy1 thy2</code> computes the conjunction of the two theories <code>thy1</code> and <code>thy2</code>. This is useful for supporting compilation units with top-level cofibration declarations.</p></div></div></div></body></html>
